package com.example.sit305101d.presentation.screens.task

import android.util.Log
import android.widget.Toast
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.RadioButton
import androidx.compose.material3.RadioButtonDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.sit305101d.data.network.RegisterRequest
import com.example.sit305101d.data.network.RetrofitClient
import com.example.sit305101d.presentation.theme.AppPrimaryColor
import com.example.sit305101d.presentation.theme.SIT305101DTheme
import com.example.sit305101d.presentation.theme.TextColorPrimary
import com.example.sit305101d.presentation.theme.TextColorSecondary
import com.example.sit305101d.presentation.theme.appBackgroundGradient
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import org.koin.android.annotation.KoinViewModel
import java.net.URLDecoder
import java.net.URLEncoder

@Composable
fun TaskScreen(
    onSubmit: (String) -> Unit,
    viewModel: TaskViewModel,
    userId: String,
    modifier: Modifier = Modifier
) {
    Log.d("TaskScreenComposable", "TaskScreen composable function started.")

    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current
    val task = uiState.taskDetails

    // Decode the task title if it's encoded
    val decodedTitle = task?.title?.let {
        try {
            URLDecoder.decode(it, "UTF-8")
        } catch (e: Exception) {
            it
        }
    } ?: ""

    LaunchedEffect(uiState.navigateToResults) {
        if (uiState.navigateToResults) {
            val encodedTaskId = task?.id?.let {
                URLEncoder.encode(it, "UTF-8")
            } ?: ""
            onSubmit(encodedTaskId)
            viewModel.onSubmissionHandled()
        }
    }

    LaunchedEffect(uiState.errorMessage) {
        uiState.errorMessage?.let {
            Toast.makeText(context, it, Toast.LENGTH_LONG).show()
            viewModel.onErrorMessageHandled()
        }
    }

    Box(
        modifier = modifier
            .fillMaxSize()
            .background(appBackgroundGradient)
    ) {
        if (uiState.isLoading) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        } else if (task != null) {
            Column(modifier = Modifier.fillMaxSize()) {
                LazyColumn(
                    modifier = Modifier
                        .weight(1f)
                        .padding(horizontal = 16.dp),
                    contentPadding = PaddingValues(top = 32.dp, bottom = 16.dp)
                ) {
                    item {
                        if (task.isAiGenerated) {
                            Text(
                                text = "âœ¨ Generated by AI",
                                fontSize = 14.sp,
                                color = TextColorSecondary,
                                modifier = Modifier.padding(bottom = 4.dp)
                            )
                        }
                        Text(
                            text = decodedTitle,
                            fontSize = 24.sp,
                            fontWeight = FontWeight.Bold,
                            color = TextColorPrimary
                        )
                        Spacer(modifier = Modifier.height(4.dp))
                        Text(
                            text = task.description,
                            fontSize = 14.sp,
                            color = TextColorSecondary
                        )
                        Spacer(modifier = Modifier.height(24.dp))
                    }

                    itemsIndexed(task.questions, key = { _, q -> q.id }) { index, question ->
                        QuestionCard(
                            questionIndex = index + 1,
                            question = question,
                            selectedOptionIndex = uiState.selectedAnswers[question.id],
                            onOptionSelected = { optionIndex ->
                                viewModel.onAnswerSelected(question.id, optionIndex)
                            },
                            enabled = !uiState.isSubmitting
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                    }
                }

                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .background(Color.Transparent)
                        .padding(horizontal = 16.dp, vertical = 24.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Button(
                        onClick = { viewModel.onSubmitClicked(userId) },
                        modifier = Modifier.fillMaxWidth().height(50.dp),
                        shape = RoundedCornerShape(8.dp),
                        enabled = uiState.selectedAnswers.size == task.questions.size && !uiState.isSubmitting,
                        colors = ButtonDefaults.buttonColors(containerColor = AppPrimaryColor)
                    ) {
                        if (uiState.isSubmitting) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(24.dp),
                                color = Color.White,
                                strokeWidth = 3.dp
                            )
                        } else {
                            Text("Submit", color = Color.White, fontSize = 18.sp)
                        }
                    }
                }
            }
        } else {
            Box(modifier = Modifier.fillMaxSize().padding(16.dp), contentAlignment = Alignment.Center) {
                Text("Task could not be loaded.", color = TextColorPrimary)
            }
        }
    }
}

@Composable
fun QuestionCard(
    questionIndex: Int,
    question: TaskQuestionUiModel,
    selectedOptionIndex: Int?,
    onOptionSelected: (Int) -> Unit,
    enabled: Boolean,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = Color(0x4DFFFFFF))
    ) {
        Column(modifier = modifier.padding(16.dp)) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(
                    text = "$questionIndex. ${question.questionText}",
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold,
                    color = if (enabled) TextColorPrimary else TextColorPrimary.copy(alpha = 0.6f)
                )
                Box(
                    modifier = Modifier
                        .size(24.dp)
                        .background(
                            color = if (selectedOptionIndex != null) AppPrimaryColor else Color.Gray,
                            shape = CircleShape
                        )
                        .then(if (!enabled) Modifier.alpha(0.6f) else Modifier)
                )
            }
            question.description?.let {
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = it,
                    fontSize = 14.sp,
                    color = if (enabled) TextColorSecondary else TextColorSecondary.copy(alpha = 0.6f)
                )
            }
            Spacer(modifier = Modifier.height(16.dp))

            question.options.forEachIndexed { index, option ->
                Row(
                    Modifier
                        .fillMaxWidth()
                        .selectable(
                            selected = (selectedOptionIndex == index),
                            onClick = { if (enabled) onOptionSelected(index) },
                            enabled = enabled
                        )
                        .padding(vertical = 4.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    RadioButton(
                        selected = (selectedOptionIndex == index),
                        onClick = { if (enabled) onOptionSelected(index) },
                        enabled = enabled,
                        colors = RadioButtonDefaults.colors(
                            selectedColor = AppPrimaryColor,
                            unselectedColor = TextColorPrimary,
                            disabledSelectedColor = AppPrimaryColor.copy(alpha = 0.6f),
                            disabledUnselectedColor = TextColorPrimary.copy(alpha = 0.6f)
                        )
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = option,
                        color = if (enabled) TextColorPrimary else TextColorPrimary.copy(alpha = 0.6f)
                    )
                }
            }
        }
    }
}

@Preview(showBackground = true)
@Composable
fun TaskScreenPreview() {
    SIT305101DTheme {
        // Preview will break because it needs a TaskViewModel instance now.
        // We can fix this later or provide a dummy instance if needed for previews.
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            Text("Preview not available - requires TaskViewModel")
        }
    }
}

// Represents the state of the SignUp UI
data class SignUpUiState(
    val username: String = "",
    val email: String = "",
    val confirmEmail: String = "",
    val password: String = "",
    val confirmPassword: String = "",
    val phoneNumber: String = "",
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val signUpSuccess: Boolean = false // Flag to trigger navigation
)

@KoinViewModel
class SignUpViewModel : ViewModel() {

    private val _uiState = MutableStateFlow(SignUpUiState())
    val uiState: StateFlow<SignUpUiState> = _uiState.asStateFlow()

    fun onUsernameChanged(username: String) {
        _uiState.update { it.copy(username = username) }
    }

    fun onEmailChanged(email: String) {
        _uiState.update { it.copy(email = email) }
    }

    fun onConfirmEmailChanged(confirmEmail: String) {
        _uiState.update { it.copy(confirmEmail = confirmEmail) }
    }

    fun onPasswordChanged(password: String) {
        _uiState.update { it.copy(password = password) }
    }

    fun onConfirmPasswordChanged(confirmPassword: String) {
        _uiState.update { it.copy(confirmPassword = confirmPassword) }
    }

    fun onPhoneNumberChanged(phoneNumber: String) {
        _uiState.update { it.copy(phoneNumber = phoneNumber) }
    }

    private fun validateInputs(): String? {
        return when {
            uiState.value.email != uiState.value.confirmEmail ->
                "Emails do not match"
            uiState.value.password != uiState.value.confirmPassword ->
                "Passwords do not match"
            uiState.value.password.length < 6 ->
                "Password must be at least 6 characters"
            uiState.value.phoneNumber.length < 10 ->
                "Please enter a valid phone number"
            else -> null
        }
    }

    fun onSignUpClicked() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            try {
                // Validate inputs
                val validationError = validateInputs()
                if (validationError != null) {
                    throw Exception(validationError)
                }

                // Call the API to register the user
                RetrofitClient.instance.register(
                    RegisterRequest(
                        username = uiState.value.username,
                        password = uiState.value.password,
                        email = uiState.value.email,
                        phone = uiState.value.phoneNumber
                    )
                )
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        signUpSuccess = true
                    )
                }
            } catch (e: Exception) {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        errorMessage = "Sign up failed: ${e.message}"
                    )
                }
            }
        }
    }

    // Call this after navigation has occurred
    fun onSignUpHandled() {
        _uiState.update { it.copy(signUpSuccess = false) }
    }

    // Call this after error message has been shown
    fun onErrorMessageHandled() {
        _uiState.update { it.copy(errorMessage = null) }
    }
}
